<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Stylish Image Text Overlay</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Montserrat:wght@300;400;600;700&family=Poppins:wght@300;400;600;700&family=Lora:wght@400;500;600&family=Dancing+Script:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 0; color: #f1f5f9; transition: background 0.3s, color 0.3s; }
        body.dark { background: linear-gradient(135deg, #1e293b, #0f172a); color: #f1f5f9; }
        body.light { background: linear-gradient(135deg, #f0f4f8, #d9e2ec); color: #2c3e50; }
        .container { display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .top-row { display: flex; flex-wrap: wrap; justify-content: center; width: 100%; gap: 20px; }
        .preview-panel, .control-panel { background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); border-radius: 16px; padding: 16px; box-shadow: 0 6px 16px rgba(0, 0, 0, .4); flex: 1; min-width: 300px; max-width: 600px; height: auto; }
        body.light .preview-panel, body.light .control-panel, body.light .results-panel { background: rgba(255, 255, 255, 0.85); color: #2c3e50; }
        body.light h2 { color: #007bff; }
        body.light label { color: #34495e; }
        body.light input, body.light textarea, body.light select { background: #ecf0f1; color: #2c3e50; }
        body.light .slider-value, body.light .status-text { color: #7f8c8d; }
        body.light .progress-container { background: #bdc3c7; }
        body.light .btn { background: linear-gradient(135deg, #3498db, #2980b9); }
        body.light .btn:disabled { background: #95a5a6; }
        body.light .result-item { background: rgba(255, 255, 255, .9); }
        body.light .tab-buttons .tab-btn.active { background: linear-gradient(135deg, #3498db, #2980b9); }
        .results-panel { background: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); border-radius: 16px; margin: 20px 0; padding: 16px; box-shadow: 0 6px 16px rgba(0, 0, 0, .4); width: 90%; max-width: 1200px; }
        h2 { margin: 0 0 8px; font-size: 16px; color: #93c5fd; }
        h3 { margin: 12px 0 6px 0; font-size: 14px; color: #a5b4fc; }
        label { display: block; margin-top: 6px; font-weight: 600; font-size: 11px; color: #e2e8f0; }
        input, textarea, select { width: 100%; padding: 5px; margin-top: 3px; border: none; border-radius: 6px; background: #1e293b; color: #f8fafc; resize: none; font-size: 11px; }
        input[type="color"] { padding: 1px; height: 28px; cursor: pointer; }
        input[type="range"] { cursor: pointer; }
        .slider-container { display: flex; align-items: center; gap: 6px; }
        .slider-value { font-size: 10px; color: #cbd5e1; }
        .btn { display: inline-block; margin: 4px; padding: 6px 10px; border: none; border-radius: 6px; background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #fff; cursor: pointer; font-weight: 600; font-size: 11px; transition: transform .2s, box-shadow .2s; }
        .btn:disabled { background: #4b5563; cursor: not-allowed; }
        .btn:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 4px 12px rgba(37, 99, 235, .6); }
        .progress-container { margin-top: 8px; height: 14px; background: #334155; border-radius: 6px; overflow: hidden; }
        .progress-bar { height: 100%; width: 0; background: linear-gradient(90deg, #60a5fa, #3b82f6); transition: width .3s; }
        .status-text { margin-top: 3px; font-size: 11px; color: #cbd5e1; }
        .results { display: grid; gap: 16px; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); }
        .result-item { background: rgba(30, 41, 59, .9); border-radius: 12px; padding: 12px; box-shadow: 0 4px 10px rgba(0, 0, 0, .4); transition: transform .2s; }
        .result-item:hover { transform: translateY(-4px); }
        .result-item img { max-width: 100%; border-radius: 8px; }
        .preview { text-align: center; }
        .preview canvas { max-width: 100%; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, .6); }
        #themeToggle { position: fixed; top: 20px; right: 20px; z-index: 1000; }
        #goToTop { position: fixed; bottom: 20px; right: 20px; z-index: 1000; padding: 10px 15px; border-radius: 50%; font-size: 14px; display: none; }
        
        /* Tab Styles */
        .tab-buttons { display: flex; gap: 4px; margin-bottom: 16px; flex-wrap: wrap; }
        .tab-btn { padding: 8px 16px; border: none; border-radius: 8px 8px 0 0; background: #334155; color: #cbd5e1; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.3s; }
        .tab-btn.active { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: #fff; box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3); }
        .tab-btn:hover:not(.active) { background: #475569; color: #e2e8f0; }
        body.light .tab-btn { background: #e2e8f0; color: #475569; }
        body.light .tab-btn.active { background: linear-gradient(135deg, #3498db, #2980b9); color: #fff; }
        body.light .tab-btn:hover:not(.active) { background: #d1d5db; color: #374151; }
        
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .text-section { border: 1px solid #475569; border-radius: 8px; padding: 12px; margin: 8px 0; background: rgba(71, 85, 105, 0.2); }
        .control-columns { display: flex; gap: 20px; margin-top: 6px; }
        .control-column { flex: 1; }
        .csv-section { position: relative; }
        .csv-toggle { position: absolute; top: 5px; right: 5px; background: rgba(37, 99, 235, 0.8); color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 10px; cursor: pointer; }
        .csv-toggle:hover { background: rgba(37, 99, 235, 1); }
        .minimized { height: 40px !important; overflow: hidden; }
        .minimized + .csv-toggle::after { content: "‚Üì"; }
        .maximized + .csv-toggle::after { content: "‚Üë"; }
        .btn-group { display: flex; flex-wrap: wrap; gap: 8px; margin: 8px 0; }
        
        @media (max-width: 768px) { 
            .top-row { flex-direction: column; } 
            .preview-panel, .control-panel, .results-panel { width: 95%; } 
            .control-columns { flex-direction: column; gap: 10px; }
            .tab-buttons { flex-direction: column; }
        }
    </style>
</head>
<body class="dark">
    <button class="btn" id="themeToggle">Switch to Light</button>
    <button class="btn" id="goToTop">‚Üë Top</button>
    <div class="container" id="layout">
        <div class="top-row">
            <div class="preview-panel">
                <h2>Live Preview</h2>
                <div class="preview"><canvas id="previewCanvas"></canvas></div>
            </div>
            <div class="control-panel" id="controls">
                <h2>Text Overlay Generator</h2>
                
                <div class="csv-section">
                    <label>CSV Input (image_url,title,detail_text)</label>
                    <textarea id="csvInput" rows="4">https://image.lexica.art/full_jpg/80e57495-6d21-4156-80c7-11742bf8c064,Sample Title,This is detail texthttps://image.lexica.art/full_jpg/275cb6fb-33ca-4418-8611-bfc5da6a703a,Sample Title,This is detail texthttps://image.lexica.art/full_jpg/85ef1582-25b8-4801-8560-a1b6b5e01c40,Sample Title,This is detail texthttps://image.lexica.art/full_jpg/4bdafa6d-e9c4-4811-8e2a-13764083dbc0,Sample Title,This is detail texthttps://image.lexica.art/full_jpg/35e16d73-d01e-4733-9922-750c133fd56a,Sample Title,This is detail text</textarea>
                    <button class="csv-toggle" onclick="toggleCsv()">‚Üë</button>
                </div>
                
                <div class="tab-buttons">
                    <button class="tab-btn active" data-tab="title">üé® Title</button>
                    <button class="tab-btn" data-tab="detail">üìù Detail</button>
                    <button class="tab-btn" data-tab="generator">‚ö° Generate</button>
                </div>

                <div id="title-tab" class="tab-content active">
                    <div class="text-section">
                        <h3>üé≠ Title Styling</h3>
                        <label>Title Size</label>
                        <div class="slider-container">
                            <input type="range" id="titleSize" min="10" max="120" value="48">
                            <span class="slider-value" id="titleSizeValue">48</span>
                        </div>
                        <label>Title Color</label><input type="color" id="titleColor" value="#ffffff">
                        <label>Title Background Color 1</label><input type="color" id="titleBg1" value="#00000080">
                        <label>Title Background Color 2</label><input type="color" id="titleBg2" value="#000000">
                        <label>Title Background Opacity</label>
                        <div class="slider-container">
                            <input type="range" id="titleBgOpacity" min="0" max="100" value="70">
                            <span class="slider-value" id="titleBgOpacityValue">70</span>
                        </div>
                        <label>Title Border Color</label><input type="color" id="titleBorderColor" value="#ffffff">
                        <label>Title Glow Color</label><input type="color" id="titleGlowColor" value="#ff6b6b">
                        <label>Title Shadow Blur</label>
                        <div class="slider-container">
                            <input type="range" id="titleShadowBlur" min="0" max="30" value="15">
                            <span class="slider-value" id="titleShadowBlurValue">15</span>
                        </div>
                        <label>Title Font Family</label>
                        <select id="titleFontFamily">
                            <option value="Playfair Display">Playfair Display</option>
                            <option value="Montserrat">Montserrat</option>
                            <option value="Poppins">Poppins</option>
                            <option value="Lora">Lora</option>
                            <option value="Dancing Script">Dancing Script</option>
                            <option value="Great Vibes">Great Vibes</option>
                            <option value="Segoe UI">Segoe UI</option>
                            <option value="Arial">Arial</option>
                        </select>
                    </div>
                    
                    <div class="control-columns">
                        <div class="control-column">
                            <label>Adjust Title Position</label>
                            <div class="slider-container">
                                <input type="range" id="titleSlider" min="-100" max="300" value="0">
                                <span class="slider-value" id="titleSliderValue">0</span>
                            </div>
                            <label>Title Alignment</label>
                            <select id="titleAlign">
                                <option value="center">Center</option>
                                <option value="left">Left</option>
                                <option value="right">Right</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="detail-tab" class="tab-content">
                    <div class="text-section">
                        <h3>üìÑ Detail Styling</h3>
                        <label>Detail Size</label>
                        <div class="slider-container">
                            <input type="range" id="detailSize" min="10" max="80" value="28">
                            <span class="slider-value" id="detailSizeValue">28</span>
                        </div>
                        <label>Detail Color</label><input type="color" id="detailColor" value="#f8fafc">
                        <label>Detail Background Color 1</label><input type="color" id="detailBg1" value="#00000000">
                        <label>Detail Background Color 2</label><input type="color" id="detailBg2" value="#000000">
                        <label>Detail Background Opacity</label>
                        <div class="slider-container">
                            <input type="range" id="detailBgOpacity" min="0" max="100" value="85">
                            <span class="slider-value" id="detailBgOpacityValue">85</span>
                        </div>
                        <label>Detail Border Color</label><input type="color" id="detailBorderColor" value="#e2e8f0">
                        <label>Detail Glow Color</label><input type="color" id="detailGlowColor" value="#4f46e5">
                        <label>Detail Shadow Blur</label>
                        <div class="slider-container">
                            <input type="range" id="detailShadowBlur" min="0" max="30" value="10">
                            <span class="slider-value" id="detailShadowBlurValue">10</span>
                        </div>
                        <label>Detail Font Family</label>
                        <select id="detailFontFamily">
                            <option value="Montserrat">Montserrat</option>
                            <option value="Poppins">Poppins</option>
                            <option value="Lora">Lora</option>
                            <option value="Segoe UI">Segoe UI</option>
                            <option value="Arial">Arial</option>
                        </select>
                    </div>
                    
                    <div class="control-columns">
                        <div class="control-column">
                            <label>Adjust Detail Position</label>
                            <div class="slider-container">
                                <input type="range" id="detailSlider" min="-100" max="300" value="0">
                                <span class="slider-value" id="detailSliderValue">0</span>
                            </div>
                            <label>Detail Alignment</label>
                            <select id="detailAlign">
                                <option value="center">Center</option>
                                <option value="left">Left</option>
                                <option value="right">Right</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="generator-tab" class="tab-content">
                    <div class="text-section">
                        <h3>‚ö° Generation Settings</h3>
                        <label>Output Size</label>
                        <select id="outputSize">
                            <option value="original" selected>Original</option>
                            <option value="reel">1080x1920 (Reel)</option>
                            <option value="youtube">1920x1080 (YouTube)</option>
                        </select>
                        <label>Custom Font (CSS Font)</label>
                        <input type="text" id="customFont" placeholder="e.g., 'Custom Font', sans-serif" value="">
                        
                        <div class="btn-group">
                            <button class="btn" id="singleBtn">Generate Single</button>
                            <button class="btn" id="generateBtn">Generate All</button>
                            <button class="btn" id="clearBtn">Clear Results</button>
                            <button class="btn" id="resetBtn">Reset Settings</button>
                            <button class="btn" id="exportZipBtn">Export as ZIP</button>
                        </div>
                    </div>
                    <div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
                    <div class="status-text" id="statusText">Ready to generate!</div>
                </div>

            </div>
        </div>
        <div class="results-panel">
            <h2>Generated Results</h2>
            <div id="results" class="results"></div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        // Constants
        const DEFAULT_SETTINGS = {
            titleSize: 48,
            detailSize: 28,
            titleColor: '#ffffff',
            detailColor: '#f8fafc',
            titleBg1: '#00000080',
            titleBg2: '#000000',
            detailBg1: '#00000000',
            detailBg2: '#000000',
            titleBgOpacity: 70,
            detailBgOpacity: 85,
            titleBorderColor: '#ffffff',
            detailBorderColor: '#e2e8f0',
            titleGlowColor: '#ff6b6b',
            detailGlowColor: '#4f46e5',
            titleShadowBlur: 15,
            detailShadowBlur: 10,
            titleSlider: 0,
            detailSlider: 0,
            titleAlign: 'center',
            detailAlign: 'center',
            titleFontFamily: 'Playfair Display',
            detailFontFamily: 'Montserrat',
            customFont: '',
            outputSize: 'original'
        };
        const MAX_PREVIEW_SIZE = 600;
        const DEBOUNCE_DELAY = 300;

        // DOM Elements
        const elements = {
            layout: document.getElementById('layout'),
            previewCanvas: document.getElementById('previewCanvas'),
            results: document.getElementById('results'),
            progressBar: document.getElementById('progressBar'),
            statusText: document.getElementById('statusText'),
            csvInput: document.getElementById('csvInput'),
            inputs: [
                'titleSize', 'detailSize', 'titleColor', 'detailColor', 'titleBg1', 'titleBg2', 
                'detailBg1', 'detailBg2', 'titleBgOpacity', 'detailBgOpacity', 
                'titleBorderColor', 'detailBorderColor', 'titleGlowColor', 'detailGlowColor', 
                'titleShadowBlur', 'detailShadowBlur', 'titleSlider', 'detailSlider', 
                'titleAlign', 'detailAlign', 'titleFontFamily', 'detailFontFamily', 
                'customFont', 'outputSize', 'csvInput'
            ].map(id => document.getElementById(id)),
            buttons: {
                single: document.getElementById('singleBtn'),
                generate: document.getElementById('generateBtn'),
                clear: document.getElementById('clearBtn'),
                reset: document.getElementById('resetBtn'),
                exportZip: document.getElementById('exportZipBtn')
            }
        };
        const ctx = elements.previewCanvas.getContext('2d');
        const themeToggle = document.getElementById('themeToggle');
        const goToTop = document.getElementById('goToTop');

        // Image Cache
        const imageCache = new Map();

        // Tab Management
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');

        const switchTab = (tabName) => {
            // Update button states
            tabButtons.forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            
            // Update content visibility
            tabContents.forEach(content => content.classList.remove('active'));
            document.getElementById(`${tabName}-tab`).classList.add('active');
        };

        // CSV Toggle
        function toggleCsv() {
            const csvInput = document.getElementById('csvInput');
            const toggleBtn = document.querySelector('.csv-toggle');
            
            if (csvInput.classList.contains('minimized')) {
                csvInput.classList.remove('minimized');
                csvInput.removeAttribute('rows');
                csvInput.setAttribute('rows', '4');
                toggleBtn.textContent = '‚Üë';
            } else {
                csvInput.classList.add('minimized');
                csvInput.setAttribute('rows', '1');
                toggleBtn.textContent = '‚Üì';
            }
        }

        // Utility Functions
        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };

        const validateCsvLine = (line) => {
            const parts = line.split(',');
            return parts.length === 3 && parts.every(part => part.trim());
        };

        const loadImage = async (src) => {
            if (imageCache.has(src)) return imageCache.get(src);
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    imageCache.set(src, img);
                    resolve(img);
                };
                img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
                img.src = src;
            });
        };

        const drawRoundedRect = (x, y, w, h, r, ctx) => {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        };

        const getSettings = () => ({
            titleSize: +document.getElementById('titleSize').value,
            detailSize: +document.getElementById('detailSize').value,
            titleColor: document.getElementById('titleColor').value,
            detailColor: document.getElementById('detailColor').value,
            titleBg1: document.getElementById('titleBg1').value,
            titleBg2: document.getElementById('titleBg2').value,
            detailBg1: document.getElementById('detailBg1').value,
            detailBg2: document.getElementById('detailBg2').value,
            titleBgOpacity: +document.getElementById('titleBgOpacity').value,
            detailBgOpacity: +document.getElementById('detailBgOpacity').value,
            titleBorderColor: document.getElementById('titleBorderColor').value,
            detailBorderColor: document.getElementById('detailBorderColor').value,
            titleGlowColor: document.getElementById('titleGlowColor').value,
            detailGlowColor: document.getElementById('detailGlowColor').value,
            titleShadowBlur: +document.getElementById('titleShadowBlur').value,
            detailShadowBlur: +document.getElementById('detailShadowBlur').value,
            titleAlign: document.getElementById('titleAlign').value,
            detailAlign: document.getElementById('detailAlign').value,
            titleFontFamily: document.getElementById('titleFontFamily').value,
            detailFontFamily: document.getElementById('detailFontFamily').value,
            customFont: document.getElementById('customFont').value,
            outputSize: document.getElementById('outputSize').value
        });

        const drawTextOverlay = (img, title, detail, settings, titleOffset, detailOffset, canvasEl, drawingScale = 1) => {
            const ctx = canvasEl.getContext('2d');

            // Calculate crop for cover fit
            const targetRatio = canvasEl.width / canvasEl.height;
            const imgRatio = img.width / img.height;
            let sx = 0, sy = 0, sw = img.width, sh = img.height;
            
            if (imgRatio > targetRatio) {
                // Image is wider, crop sides
                sw = img.height * targetRatio;
                sx = (img.width - sw) / 2;
                sh = img.height;
            } else if (imgRatio < targetRatio) {
                // Image is taller, crop top/bottom
                sh = img.width / targetRatio;
                sy = (img.height - sh) / 2;
                sw = img.width;
            }
            
            ctx.drawImage(img, sx, sy, sw, sh, 0, 0, canvasEl.width, canvasEl.height);

            // Margins and paddings scaled
            const margin = 30 * drawingScale;
            const padding = 12 * drawingScale;
            const borderWidth = 3 * drawingScale;
            const cornerRadius = 15 * drawingScale;

            // Get font family
            const titleFont = settings.customFont ? `"${settings.customFont}"` : settings.titleFontFamily;
            const detailFont = settings.customFont ? `"${settings.customFont}"` : settings.detailFontFamily;

            // TITLE DRAWING - EXACT SAME AS EXPORT
            ctx.font = `bold ${settings.titleSize * drawingScale}px ${titleFont}`;
            ctx.textAlign = settings.titleAlign;
            ctx.textBaseline = 'top';
            
            const titleMetrics = ctx.measureText(title);
            const titleWidth = titleMetrics.width;
            const titleHeight = settings.titleSize * drawingScale;
            const titleX = settings.titleAlign === 'left' ? margin : 
                          settings.titleAlign === 'right' ? canvasEl.width - margin : 
                          canvasEl.width / 2;
            const titleY = margin + titleOffset * drawingScale;

            // Title Background - EXACT SAME AS EXPORT
            const titleBgGradient = ctx.createLinearGradient(
                titleX - titleWidth / 2 - padding, titleY - padding,
                titleX + titleWidth / 2 + padding, titleY + titleHeight + padding
            );
            titleBgGradient.addColorStop(0, settings.titleBg1);
            titleBgGradient.addColorStop(1, settings.titleBg2);
            
            ctx.save();
            ctx.globalAlpha = settings.titleBgOpacity / 100;
            ctx.fillStyle = titleBgGradient;
            drawRoundedRect(
                titleX - titleWidth / 2 - padding, 
                titleY - padding, 
                titleWidth + padding * 2, 
                titleHeight + padding * 2, 
                cornerRadius, 
                ctx
            );
            ctx.fill();
            ctx.restore();

            // Title Border and Glow - EXACT SAME AS EXPORT
            ctx.strokeStyle = settings.titleBorderColor;
            ctx.lineWidth = borderWidth;
            ctx.shadowColor = settings.titleGlowColor;
            ctx.shadowBlur = settings.titleShadowBlur * drawingScale;
            
            ctx.strokeText(title, titleX, titleY);
            
            // Title Fill - EXACT SAME AS EXPORT
            ctx.shadowBlur = 0;
            ctx.fillStyle = settings.titleColor;
            ctx.fillText(title, titleX, titleY);

            // DETAIL DRAWING - EXACT SAME AS EXPORT
            const lines = detail.split('\n');
            const lineHeight = settings.detailSize * drawingScale * 1.2;
            
            lines.forEach((line, i) => {
                ctx.font = `${settings.detailSize * drawingScale}px ${detailFont}`;
                ctx.textAlign = settings.detailAlign;
                const textWidth = ctx.measureText(line).width;
                const detailX = settings.detailAlign === 'left' ? margin : 
                               settings.detailAlign === 'right' ? canvasEl.width - margin : 
                               canvasEl.width / 2;
                const lineY = canvasEl.height - (lines.length - i) * lineHeight - margin - detailOffset * drawingScale;
                
                // Detail Background - EXACT SAME AS EXPORT
                const detailBgGradient = ctx.createLinearGradient(
                    detailX - textWidth / 2 - padding, lineY - padding,
                    detailX + textWidth / 2 + padding, lineY + settings.detailSize * drawingScale + padding
                );
                detailBgGradient.addColorStop(0, settings.detailBg1);
                detailBgGradient.addColorStop(1, settings.detailBg2);
                
                ctx.save();
                ctx.globalAlpha = settings.detailBgOpacity / 100;
                ctx.fillStyle = detailBgGradient;
                drawRoundedRect(
                    detailX - textWidth / 2 - padding, 
                    lineY - padding, 
                    textWidth + padding * 2, 
                    settings.detailSize * drawingScale + padding * 2, 
                    cornerRadius * 0.7, 
                    ctx
                );
                ctx.fill();
                ctx.restore();

                // Detail Border and Glow - EXACT SAME AS EXPORT
                ctx.strokeStyle = settings.detailBorderColor;
                ctx.lineWidth = borderWidth * 0.7;
                ctx.shadowColor = settings.detailGlowColor;
                ctx.shadowBlur = settings.detailShadowBlur * drawingScale;
                
                ctx.strokeText(line, detailX, lineY);
                
                // Detail Fill - EXACT SAME AS EXPORT
                ctx.shadowBlur = 0;
                ctx.fillStyle = settings.detailColor;
                ctx.fillText(line, detailX, lineY);
            });

            return canvasEl.toDataURL('image/png');
        };

        const updateSliderValues = () => {
            ['titleSize', 'detailSize', 'titleBgOpacity', 'detailBgOpacity', 'titleShadowBlur', 'detailShadowBlur', 'titleSlider', 'detailSlider'].forEach(id => {
                const value = document.getElementById(id).value;
                document.getElementById(`${id}Value`).textContent = value;
            });
        };

        const updatePreview = debounce(async () => {
            const settings = getSettings();
            const csvLines = elements.csvInput.value.trim().split('\n').filter(l => l && validateCsvLine(l));
            if (!csvLines.length) {
                elements.statusText.textContent = 'No valid CSV input provided.';
                return;
            }
            const [src, title, detail] = csvLines[0].split(',');
            try {
                const img = await loadImage(src.trim());
                let targetW, targetH;
                if (settings.outputSize === 'original') {
                    targetW = img.width;
                    targetH = img.height;
                } else if (settings.outputSize === 'reel') {
                    targetW = 1080;
                    targetH = 1920;
                } else {
                    targetW = 1920;
                    targetH = 1080;
                }
                
                // Calculate preview scale to fit MAX_PREVIEW_SIZE
                const scaleX = MAX_PREVIEW_SIZE / targetW;
                const scaleY = MAX_PREVIEW_SIZE / targetH;
                const previewScale = Math.min(scaleX, scaleY, 1);
                const previewW = targetW * previewScale;
                const previewH = targetH * previewScale;
                
                elements.previewCanvas.width = previewW;
                elements.previewCanvas.height = previewH;
                
                // Use the SAME drawing function with preview scale
                drawTextOverlay(
                    img,
                    title.trim(),
                    detail.trim(),
                    settings,
                    +document.getElementById('titleSlider').value,
                    +document.getElementById('detailSlider').value,
                    elements.previewCanvas,
                    previewScale // Apply scaling to maintain proportions
                );
                elements.statusText.textContent = 'Live preview updated.';
            } catch (e) {
                elements.statusText.textContent = `Preview failed: ${e.message}`;
            }
        }, DEBOUNCE_DELAY);

        const disableButtons = (disabled) => {
            Object.values(elements.buttons).forEach(btn => btn.disabled = disabled);
        };

        const generateSingle = async () => {
            const csvLines = elements.csvInput.value.trim().split('\n').filter(l => l && validateCsvLine(l));
            if (!csvLines.length) {
                elements.statusText.textContent = 'Please add valid CSV input first.';
                return;
            }
            disableButtons(true);
            const settings = getSettings();
            const [src, title, detail] = csvLines[0].split(',');
            try {
                elements.statusText.textContent = 'Generating single image...';
                const img = await loadImage(src.trim());
                let targetW, targetH;
                if (settings.outputSize === 'original') {
                    targetW = img.width;
                    targetH = img.height;
                } else if (settings.outputSize === 'reel') {
                    targetW = 1080;
                    targetH = 1920;
                } else {
                    targetW = 1920;
                    targetH = 1080;
                }
                
                // Create full-size canvas - SAME as preview logic but full size
                const fullCanvas = document.createElement('canvas');
                fullCanvas.width = targetW;
                fullCanvas.height = targetH;
                
                // Use EXACT SAME drawing function with scale=1 for full quality
                const dataUrl = drawTextOverlay(
                    img,
                    title.trim(),
                    detail.trim(),
                    settings,
                    +document.getElementById('titleSlider').value,
                    +document.getElementById('detailSlider').value,
                    fullCanvas,
                    1 // Full scale for export
                );
                
                elements.results.innerHTML = '';
                const div = document.createElement('div');
                div.className = 'result-item';
                div.innerHTML = `
                    <img src="${dataUrl}">
                    <br>
                    <a class="btn" href="${dataUrl}" download="overlay.png">Download PNG</a>
                `;
                elements.results.appendChild(div);
                elements.statusText.textContent = 'Single image generated! Preview matches export.';
            } catch (e) {
                elements.statusText.textContent = `Image load failed: ${src}`;
            } finally {
                disableButtons(false);
            }
        };

        const generateAll = async () => {
            const csvLines = elements.csvInput.value.trim().split('\n').filter(l => l && validateCsvLine(l));
            if (!csvLines.length) {
                elements.statusText.textContent = 'Please add valid CSV input first.';
                return;
            }
            disableButtons(true);
            elements.results.innerHTML = '';
            const settings = getSettings();
            
            for (let i = 0; i < csvLines.length; i++) {
                elements.statusText.textContent = `Generating ${i + 1} of ${csvLines.length}...`;
                elements.progressBar.style.width = `${((i + 1) / csvLines.length) * 100}%`;
                
                const [src, title, detail] = csvLines[i].split(',');
                try {
                    const img = await loadImage(src.trim());
                    let targetW, targetH;
                    if (settings.outputSize === 'original') {
                        targetW = img.width;
                        targetH = img.height;
                    } else if (settings.outputSize === 'reel') {
                        targetW = 1080;
                        targetH = 1920;
                    } else {
                        targetW = 1920;
                        targetH = 1080;
                    }
                    
                    const fullCanvas = document.createElement('canvas');
                    fullCanvas.width = targetW;
                    fullCanvas.height = targetH;
                    
                    // Use EXACT SAME drawing function
                    const dataUrl = drawTextOverlay(
                        img,
                        title.trim(),
                        detail.trim(),
                        settings,
                        +document.getElementById('titleSlider').value,
                        +document.getElementById('detailSlider').value,
                        fullCanvas,
                        1
                    );
                    
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    div.innerHTML = `
                        <img src="${dataUrl}">
                        <br>
                        <a class="btn" href="${dataUrl}" download="overlay_${i + 1}.png">Download PNG</a>
                    `;
                    elements.results.appendChild(div);
                } catch (e) {
                    console.error(`Failed to generate image ${i + 1}:`, e);
                }
            }
            elements.statusText.textContent = 'All images generated! Preview matches exports.';
            disableButtons(false);
        };

        const exportAsZip = async () => {
            const csvLines = elements.csvInput.value.trim().split('\n').filter(l => l && validateCsvLine(l));
            if (!csvLines.length) {
                elements.statusText.textContent = 'Please add valid CSV input first.';
                return;
            }
            disableButtons(true);
            const zip = new JSZip();
            const settings = getSettings();
            
            for (let i = 0; i < csvLines.length; i++) {
                elements.statusText.textContent = `Preparing ${i + 1} of ${csvLines.length} for ZIP...`;
                elements.progressBar.style.width = `${((i + 1) / csvLines.length) * 100}%`;
                
                const [src, title, detail] = csvLines[i].split(',');
                try {
                    const img = await loadImage(src.trim());
                    let targetW, targetH;
                    if (settings.outputSize === 'original') {
                        targetW = img.width;
                        targetH = img.height;
                    } else if (settings.outputSize === 'reel') {
                        targetW = 1080;
                        targetH = 1920;
                    } else {
                        targetW = 1920;
                        targetH = 1080;
                    }
                    
                    const fullCanvas = document.createElement('canvas');
                    fullCanvas.width = targetW;
                    fullCanvas.height = targetH;
                    
                    // Use EXACT SAME drawing function
                    const dataUrl = drawTextOverlay(
                        img,
                        title.trim(),
                        detail.trim(),
                        settings,
                        +document.getElementById('titleSlider').value,
                        +document.getElementById('detailSlider').value,
                        fullCanvas,
                        1
                    );
                    
                    const base64Data = dataUrl.split(',')[1];
                    zip.file(`overlay_${i + 1}.png`, base64Data, { base64: true });
                } catch (e) {
                    console.error(`Failed to add image ${i + 1} to ZIP:`, e);
                }
            }
            
            const content = await zip.generateAsync({ type: 'blob' });
            saveAs(content, 'text-overlays.zip');
            elements.statusText.textContent = 'ZIP file downloaded! All images match preview.';
            disableButtons(false);
        };

        const resetSettings = () => {
            // Reset all inputs to default
            Object.keys(DEFAULT_SETTINGS).forEach(key => {
                const element = document.getElementById(key);
                if (element) {
                    element.value = DEFAULT_SETTINGS[key];
                }
            });
            updateSliderValues();
            updatePreview();
            elements.statusText.textContent = 'Settings reset to default.';
        };

        // Event Listeners
        tabButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                switchTab(btn.dataset.tab);
            });
        });

        elements.buttons.single.addEventListener('click', generateSingle);
        elements.buttons.generate.addEventListener('click', generateAll);
        elements.buttons.clear.addEventListener('click', () => {
            elements.results.innerHTML = '';
            imageCache.clear();
            elements.statusText.textContent = 'Results cleared.';
        });
        elements.buttons.reset.addEventListener('click', resetSettings);
        elements.buttons.exportZip.addEventListener('click', exportAsZip);

        // Add input listeners for live preview
        elements.inputs.forEach(input => {
            input.addEventListener('input', () => {
                updateSliderValues();
                updatePreview();
            });
        });

        // Theme toggle
        themeToggle.addEventListener('click', () => {
            document.body.classList.toggle('dark');
            document.body.classList.toggle('light');
            themeToggle.textContent = document.body.classList.contains('dark') ? 'Switch to Light' : 'Switch to Dark';
        });

        // Scroll to top
        window.addEventListener('scroll', () => {
            goToTop.style.display = (window.scrollY > 100) ? 'block' : 'none';
        });
        goToTop.addEventListener('click', () => {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Initialize
        updateSliderValues();
        updatePreview();
    </script>
</body>
</html>
