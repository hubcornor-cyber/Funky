<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image → Video Converter (Client‑Side)</title>
  <style>
    :root {
      --bg-dark: #0f172a;
      --panel-dark: #111827;
      --muted-dark: #94a3b8;
      --text-dark: #e5e7eb;
      --accent-dark: #22c55e;
      --accent-2-dark: #06b6d4;
      --danger-dark: #ef4444;
      --warning-dark: #f59e0b;
      --border-dark: #1f2937;
      --shadow-dark: 0 10px 25px rgba(0,0,0,.35);
      --bg-light: #f8fafc;
      --panel-light: #ffffff;
      --muted-light: #64748b;
      --text-light: #1f2937;
      --accent-light: #16a34a;
      --accent-2-light: #0e7490;
      --danger-light: #dc2626;
      --warning-light: #d97706;
      --border-light: #e2e8f0;
      --shadow-light: 0 10px 25px rgba(0,0,0,.1);
      --radius: 16px;
      --bg: var(--bg-dark);
      --panel: var(--panel-dark);
      --muted: var(--muted-dark);
      --text: var(--text-dark);
      --accent: var(--accent-dark);
      --accent-2: var(--accent-2-dark);
      --danger: var(--danger-dark);
      --warning: var(--warning-dark);
      --border: var(--border-dark);
      --shadow: var(--shadow-dark);
    }
    [data-theme="light"] {
      --bg: var(--bg-light);
      --panel: var(--panel-light);
      --muted: var(--muted-light);
      --text: var(--text-light);
      --accent: var(--accent-light);
      --accent-2: var(--accent-2-light);
      --danger: var(--danger-light);
      --warning: var(--warning-light);
      --border: var(--border-light);
      --shadow: var(--shadow-light);
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: linear-gradient(120deg, var(--bg), var(--bg)); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; transition: background 0.3s ease, color 0.3s ease; }
    .container { max-width: 1200px; margin: 0 auto; padding: 24px; }
    header { display: flex; align-items: center; gap: 14px; margin-bottom: 18px; }
    header h1 { font-size: clamp(22px, 2.8vw, 32px); margin: 0; animation: fadeIn 1s ease-in-out; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); transition: background 0.3s ease, border 0.3s ease, box-shadow 0.3s ease; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 18px; animation: slideUp 0.5s ease; }
    @media (min-width: 960px) { .grid { grid-template-columns: 2fr 1fr; } }
    .controls { padding: 18px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    label { font-size: 13px; color: var(--muted); }
    input[type="file"] { display: none; }
    .btn { appearance: none; border: 1px solid var(--border); background: #0b1227; color: var(--text); padding: 10px 14px; border-radius: 12px; cursor: pointer; transition: .15s transform, .15s background, .3s color, .3s border; box-shadow: inset 0 0 0 1px rgba(255,255,255,.03); }
    [data-theme="light"] .btn { background: #f1f5f9; }
    .btn:hover { transform: translateY(-1px); background: #0c132b; animation: pulse 0.5s ease; }
    [data-theme="light"] .btn:hover { background: #e2e8f0; }
    .btn.primary { background: linear-gradient(135deg, var(--accent), var(--accent-2)); border: none; }
    .btn.danger { background: transparent; border-color: #3b1111; color: #fecaca; }
    [data-theme="light"] .btn.danger { border-color: #fecaca; color: #3b1111; }
    .btn.ghost { background: transparent; }
    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border: 1px dashed var(--border); border-radius: 999px; color: var(--muted); font-size: 13px; animation: bounce 1s infinite alternate; }
    .select, .number, .text { background: #0b1227; border: 1px solid var(--border); color: var(--text); padding: 10px 12px; border-radius: 12px; min-width: 90px; }
    [data-theme="light"] .select, [data-theme="light"] .number, [data-theme="light"] .text { background: #f1f5f9; }
    .number { width: 110px; }
    .text { min-width: 200px; }
    .list { padding: 14px 14px 6px; max-height: 420px; overflow: auto; border-top: 1px solid var(--border); }
    .item { display: grid; grid-template-columns: 64px 1fr auto; gap: 12px; align-items: center; padding: 10px; border: 1px solid var(--border); border-radius: 14px; margin-bottom: 10px; background: #0b1227; animation: fadeIn 0.5s ease; }
    [data-theme="light"] .item { background: #f1f5f9; }
    .thumb { width: 64px; height: 64px; border-radius: 12px; overflow: hidden; background: #0a0f1f; display: grid; place-items: center; border: 1px solid var(--border); }
    [data-theme="light"] .thumb { background: #e2e8f0; }
    .thumb img { max-width: 100%; max-height: 100%; object-fit: cover; transition: transform 0.3s ease; }
    .thumb img:hover { transform: scale(1.1); }
    .meta { display: flex; flex-direction: column; gap: 6px; }
    .meta .name { font-weight: 600; font-size: 14px; word-break: break-all; }
    .meta .sub { font-size: 12px; color: var(--muted); }
    .actions { display: flex; gap: 8px; }
    .footer { display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-between; align-items: center; padding: 14px; border-top: 1px solid var(--border); }
    .progress { height: 10px; background: #0b1120; border: 1px solid var(--border); border-radius: 999px; overflow: hidden; }
    [data-theme="light"] .progress { background: #f1f5f9; }
    .bar { height: 100%; width: 0; background: linear-gradient(90deg, var(--accent), var(--accent-2)); }
    .errors { padding: 12px 14px; color: #fecaca; background: #2b0d0d; border: 1px solid #3b1111; border-radius: 12px; margin-top: 10px; display: none; }
    [data-theme="light"] .errors { color: #2b0d0d; background: #fecaca; border-color: #fecaca; }
    .hint { font-size: 12px; color: var(--muted); }
    video { width: 100%; border-bottom-left-radius: var(--radius); border-bottom-right-radius: var(--radius); }
    .preview { padding: 14px; }
    #themeToggle { position: absolute; top: 20px; right: 20px; background: transparent; border: none; cursor: pointer; font-size: 20px; transition: transform 0.3s ease; }
    #themeToggle:hover { transform: rotate(180deg); }
    .sticker { display: inline-flex; cursor: pointer; font-size: 20px; margin: 5px; }
    .sticker:hover { transform: scale(1.2); }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
  </style>
</head>
<body data-theme="dark">
  <button id="themeToggle">🌙</button>
  <div class="container">
    <header>
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 7a2 2 0 0 1 2-2h2l1-2h6l1 2h2a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z" stroke="#22c55e" stroke-width="1.2"/><path d="M12 9.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9z" stroke="#06b6d4" stroke-width="1.2"/></svg>
      <h1>Image → Video Converter</h1>
      <span class="pill"><strong>Client‑side</strong> • No server needed • Creative Studio</span>
    </header>
    <div class="grid">
      <section class="card">
        <div class="controls">
          <div class="row" style="justify-content:space-between">
            <div class="row">
              <label for="fileInput">Images/GIFs</label>
              <label class="btn" for="fileInput">+ Add Images/GIFs</label>
              <input id="fileInput" type="file" accept="image/*,image/gif" multiple />
              <span class="hint">Tip: drag in photos or GIFs • reorder as needed</span>
            </div>
            <div class="row">
              <label for="fps">FPS</label>
              <input id="fps" class="number" type="number" min="1" max="60" value="30" />
              <label for="size">Resolution</label>
              <select id="size" class="select">
                <option value="1920x1080">YouTube (1920×1080)</option>
                <option value="1080x1920">TikTok / Reels / Shorts (1080×1920)</option>
                <option value="1080x1080">Instagram Post / Facebook Ad (1080×1080)</option>
                <option value="1280x720">Facebook / Twitter (1280×720)</option>
              </select>
            </div>
          </div>
          <div class="row" style="margin-top:12px">
            <label for="audioInput">Soundtrack</label>
            <label class="btn" for="audioInput">+ Add Audio</label>
            <input id="audioInput" type="file" accept="audio/*" />
            <span class="hint">Optional — auto-trimmed to video length</span>
          </div>
          <div class="row" style="margin-top:12px">
            <label>Transition</label>
            <select id="transType" class="select">
              <option value="none">None</option>
              <option value="fade">Fade</option>
              <option value="slide">Slide</option>
              <option value="zoom">Zoom</option>
              <option value="swirl">Swirl</option>
              <option value="flip">Flip</option>
            </select>
            <label>Duration (sec)</label>
            <input id="transDur" class="number" type="number" min="0.1" step="0.1" value="0.5" />
          </div>
          <div class="row" style="margin-top:12px">
            <label>Frame Style</label>
            <select id="frameStyle" class="select">
              <option value="none">None</option>
              <option value="rounded">Rounded</option>
              <option value="polaroid">Polaroid</option>
            </select>
            <label>Background</label>
            <select id="bgStyle" class="select">
              <option value="solid">Solid</option>
              <option value="gradient">Gradient</option>
              <option value="stars">Stars</option>
            </select>
          </div>
          <div class="row" style="margin-top:12px">
            <label>Stickers</label>
            <div id="stickers" class="row">
              <span class="sticker" data-sticker="🌟">🌟</span>
              <span class="sticker" data-sticker="❤️">❤️</span>
              <span class="sticker" data-sticker="🎉">🎉</span>
            </div>
          </div>
        </div>
        <div class="list" id="list"></div>
        <div class="footer">
          <div class="row" style="gap:14px">
            <button id="generateBtn" class="btn primary">▶ Generate Video</button>
            <select id="exportFormat" class="select">
              <option value="webm">WebM</option>
              <option value="mp4">MP4</option>
              <option value="gif">GIF</option>
            </select>
            <a id="downloadLink" class="btn ghost" download="slideshow.webm" style="display:none">⬇ Download</a>
          </div>
          <div class="progress" style="flex:1;min-width:200px"><div class="bar" id="bar"></div></div>
        </div>
        <div id="errors" class="errors"></div>
      </section>
      <section class="card">
        <div class="preview"><label>Preview</label></div>
        <video id="outVideo" controls playsinline></video>
      </section>
    </div>
  </div>
  <canvas id="canvas" style="display:none"></canvas>
  <script>
    const state = { items: [], nextId: 1, chunks: [], recorder: null, audioFile: null, stickers: [] };
    const el = id => document.getElementById(id);
    const list = el('list'), errors = el('errors'), bar = el('bar'), fileInput = el('fileInput'), fpsInput = el('fps'), sizeInput = el('size'), generateBtn = el('generateBtn'), downloadLink = el('downloadLink'), outVideo = el('outVideo'), canvas = el('canvas'), themeToggle = el('themeToggle');
    const ctx = canvas.getContext('2d');

    themeToggle.onclick = () => {
      const theme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      document.body.setAttribute('data-theme', theme);
      themeToggle.textContent = theme === 'dark' ? '🌙' : '☀️';
    };

    document.querySelectorAll('.sticker').forEach(sticker => {
      sticker.onclick = () => {
        state.stickers.push({ emoji: sticker.dataset.sticker, x: Math.random() * 0.8 + 0.1, y: Math.random() * 0.8 + 0.1 });
        renderList();
      };
    });

    function showError(m) { errors.style.display = 'block'; errors.textContent = m; }
    function clearError() { errors.style.display = 'none'; errors.textContent = ''; }
    function setProgress(p) { bar.style.width = Math.max(0, Math.min(100, p)) + '%'; }

    function renderList() {
      list.innerHTML = '';
      state.items.forEach((it, idx) => {
        const row = document.createElement('div');
        row.className = 'item';
        row.innerHTML = `
          <div class="thumb"><img src="${it.url}"></div>
          <div class="meta">
            <div class="name">${it.file.name}</div>
            <div class="sub">${it.img.naturalWidth}×${it.img.naturalHeight}${it.isGif ? ' (GIF)' : ''}</div>
            <div class="row"><label>Duration (sec)</label><input type="number" class="number" value="${it.duration}" min="0.1" step="0.1"></div>
          </div>
          <div class="actions">
            <button class="btn ghost">▲</button>
            <button class="btn ghost">▼</button>
            <button class="btn danger">Remove</button>
          </div>`;
        list.appendChild(row);
        const input = row.querySelector('input');
        input.addEventListener('input', () => {
          const v = parseFloat(input.value);
          it.duration = isFinite(v) && v > 0 ? v : 0;
        });
        row.querySelectorAll('button')[0].onclick = () => {
          if (idx > 0) [state.items[idx - 1], state.items[idx]] = [state.items[idx], state.items[idx - 1]];
          renderList();
        };
        row.querySelectorAll('button')[1].onclick = () => {
          if (idx < state.items.length - 1) [state.items[idx + 1], state.items[idx]] = [state.items[idx], state.items[idx + 1]];
          renderList();
        };
        row.querySelectorAll('button')[2].onclick = () => {
          URL.revokeObjectURL(it.url);
          state.items.splice(idx, 1);
          renderList();
        };
      });
    }

    fileInput.onchange = async e => {
      clearError();
      for (const f of e.target.files) {
        if (!/^image\//.test(f.type)) { showError(`Invalid file: ${f.name}`); continue; }
        const url = URL.createObjectURL(f);
        const isGif = f.type === 'image/gif';
        const img = new Image();
        await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = url; });
        state.items.push({ id: state.nextId++, file: f, url, img, duration: isGif ? 5 : 3, isGif });
      }
      renderList();
    };
    el('audioInput').onchange = e => {
      const f = e.target.files[0];
      state.audioFile = f && /^audio\//.test(f.type) ? f : null;
    };

    function computeCoverRect(sw, sh, dw, dh) {
      const sr = sw / sh, dr = dw / dh;
      let w, h, x, y;
      if (sr > dr) { h = dh; w = h * sr; x = (dw - w) / 2; y = 0; }
      else { w = dw; h = w / sr; x = 0; y = (dh - h) / 2; }
      return { x, y, w, h };
    }

    async function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    function drawBackground(bgStyle) {
      if (bgStyle === 'gradient') {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, '#1e3a8a');
        gradient.addColorStop(1, '#6d28d9');
        ctx.fillStyle = gradient;
      } else if (bgStyle === 'stars') {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < 50; i++) {
          ctx.fillStyle = `rgba(255,255,255,${Math.random() * 0.5 + 0.5})`;
          ctx.beginPath();
          ctx.arc(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 2, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        ctx.fillStyle = '#000';
      }
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawImage(item, alpha = 1, scale = 1, xOffset = 0, yOffset = 0, angle = 0, frameStyle = 'none') {
      ctx.save();
      ctx.globalAlpha = alpha;
      const rect = computeCoverRect(item.img.naturalWidth * scale, item.img.naturalHeight * scale, canvas.width, canvas.height);
      if (angle !== 0) {
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(angle);
        ctx.translate(-canvas.width / 2, -canvas.height / 2);
      }
      if (frameStyle === 'rounded') {
        ctx.beginPath();
        ctx.roundRect(rect.x - 10, rect.y - 10, rect.w + 20, rect.h + 20, 20);
        ctx.clip();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 5;
        ctx.stroke();
      } else if (frameStyle === 'polaroid') {
        ctx.fillStyle = '#fff';
        ctx.fillRect(rect.x - 10, rect.y - 10, rect.w + 20, rect.h + 30);
        ctx.beginPath();
        ctx.rect(rect.x - 10, rect.y - 10, rect.w + 20, rect.h + 20);
        ctx.clip();
      }
      ctx.drawImage(item.img, rect.x, rect.y, rect.w, rect.h);
      ctx.restore();
    }

    function drawStickers() {
      state.stickers.forEach(sticker => {
        ctx.font = '40px sans-serif';
        ctx.fillText(sticker.emoji, sticker.x * canvas.width, sticker.y * canvas.height);
      });
    }

    async function generate() {
      clearError();
      setProgress(0);
      downloadLink.style.display = 'none';
      outVideo.removeAttribute('src');
      outVideo.load();
      if (!state.items.length) { showError('Add images or GIFs first'); return; }
      const [W, H] = sizeInput.value.split('x').map(Number), fps = Math.max(1, Math.min(60, parseInt(fpsInput.value) || 30));
      const transType = el('transType').value;
      const transDur = transType !== 'none' ? (parseFloat(el('transDur').value) || 0.5) : 0;
      const frameStyle = el('frameStyle').value;
      const bgStyle = el('bgStyle').value;
      const exportFormat = el('exportFormat').value;
      let totalDur = state.items.reduce((a, it) => a + it.duration, 0);
      if (transType !== 'none' && state.items.length > 1) {
        for (let i = 0; i < state.items.length - 1; i++) {
          if (state.items[i].duration < transDur) {
            showError('Some image durations are shorter than transition duration.');
            return;
          }
        }
        totalDur -= (state.items.length - 1) * transDur;
      }
      canvas.width = W; canvas.height = H;
      const mime = exportFormat === 'mp4' ? 'video/mp4;codecs=avc1' : exportFormat === 'gif' ? 'image/gif' : 'video/webm;codecs=vp9';
      const stream = canvas.captureStream(fps);
      let audio = null;
      if (state.audioFile) {
        audio = new Audio(URL.createObjectURL(state.audioFile));
        audio.crossOrigin = 'anonymous';
        const ctxA = new AudioContext();
        const src = ctxA.createMediaElementSource(audio);
        const dst = ctxA.createMediaStreamDestination();
        src.connect(dst);
        src.connect(ctxA.destination);
        stream.addTrack(dst.stream.getAudioTracks()[0]);
        audio.play();
      }
      const rec = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 6_000_000 });
      state.chunks = [];
      rec.ondataavailable = e => { if (e.data.size) state.chunks.push(e.data); };
      const stopP = new Promise(r => rec.onstop = r);
      rec.start();
      let elapsed = 0;

      // Images with transitions
      for (let i = 0; i < state.items.length; i++) {
        const it = state.items[i];
        const nextIt = state.items[i + 1];
        const holdDur = (transType !== 'none' && nextIt) ? it.duration - transDur : it.duration;
        const holdFrames = Math.round(holdDur * fps);
        for (let f = 0; f < holdFrames; f++) {
          drawBackground(bgStyle);
          drawImage(it, 1, 1, 0, 0, 0, frameStyle);
          drawStickers();
          elapsed += 1 / fps;
          setProgress((elapsed / totalDur) * 100);
          await sleep(1000 / fps);
        }
        if (transType !== 'none' && nextIt) {
          const transFrames = Math.round(transDur * fps);
          for (let f = 0; f < transFrames; f++) {
            const prog = f / transFrames;
            drawBackground(bgStyle);
            if (transType === 'fade') {
              drawImage(it, 1 - prog, 1, 0, 0, 0, frameStyle);
              drawImage(nextIt, prog, 1, 0, 0, 0, frameStyle);
            } else if (transType === 'slide') {
              drawImage(it, 1, 1, -prog * W, 0, 0, frameStyle);
              drawImage(nextIt, 1, 1, (1 - prog) * W, 0, 0, frameStyle);
            } else if (transType === 'zoom') {
              drawImage(it, 1 - prog, 1 + prog, 0, 0, 0, frameStyle);
              drawImage(nextIt, prog, 1 - prog + 1, 0, 0, 0, frameStyle);
            } else if (transType === 'swirl') {
              drawImage(it, 1 - prog, 1, 0, 0, prog * Math.PI * 2, frameStyle);
              drawImage(nextIt, prog, 1, 0, 0, (1 - prog) * Math.PI * 2, frameStyle);
            } else if (transType === 'flip') {
              drawImage(it, Math.abs(Math.cos(prog * Math.PI)), 1, 0, 0, prog * Math.PI, frameStyle);
              if (prog > 0.5) drawImage(nextIt, Math.abs(Math.cos((prog - 0.5) * Math.PI)), 1, 0, 0, (prog - 0.5) * Math.PI, frameStyle);
            }
            drawStickers();
            elapsed += 1 / fps;
            setProgress((elapsed / totalDur) * 100);
            await sleep(1000 / fps);
          }
        }
      }

      rec.stop();
      await stopP;
      if (audio) audio.pause();
      const blob = new Blob(state.chunks, { type: mime });
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.style.display = 'inline-flex';
      downloadLink.download = `slideshow.${exportFormat}`;
      downloadLink.textContent = `⬇ Download (${(blob.size / 1024 / 1024).toFixed(1)} MB)`;
      outVideo.src = url;
      outVideo.play().catch(() => {});
      setProgress(100);
    }

    generateBtn.onclick = generate;
  </script>
</body>
</html>
